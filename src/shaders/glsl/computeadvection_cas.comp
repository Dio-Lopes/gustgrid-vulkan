#version 450

// Fallback version of compute advection that emulates float atomicAdd using integer CAS (atomicCompSwap) on uint-typed SSBOs.

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout(binding = 5, std430) restrict buffer VelocityBuffer { vec4 velocity[]; };
layout(binding = 6, std430) restrict writeonly buffer SpeedBuffer { float speed[]; };
layout(binding = 7, std430) restrict readonly buffer TemperatureBuffer { float temperature[]; };
layout(binding = 10, std430) buffer TempSumBufferU { uint tempSum_u[]; };
layout(binding = 11, std430) buffer WeightSumBufferU { uint weightSum_u[]; };
layout(binding = 12, std430) buffer TempSumDissBufferU { uint tempSumDiss_u[]; };
layout(binding = 14, std430) restrict readonly buffer SolidGridBuffer { uint solidGrid[]; };

layout(push_constant) uniform PushConstants {
    vec4 gridSize;
    vec4 worldMin;
    vec4 worldMax;
    vec4 cellSize;
    float deltaTime;
    uint numFans;
    int displayPressure;
    uint padding;
} pc;

const float velocityThreshold = 0.1;
const float c_ambientTemperature = 22.0;

uint idx3D(uint x, uint y, uint z){
    return uint(x + y * pc.gridSize.x + z * pc.gridSize.x * pc.gridSize.y);
}

float atomicAddTempSum(uint index, float operand){
    uint oldBits = tempSum_u[index];
    for(;;){
        float oldVal = uintBitsToFloat(oldBits);
        uint newBits = floatBitsToUint(oldVal + operand);
        uint prev = atomicCompSwap(tempSum_u[index], oldBits, newBits);
        if(prev == oldBits) return oldVal;
        oldBits = prev;
    }
}
float atomicAddWeightSum(uint index, float operand){
    uint oldBits = weightSum_u[index];
    for(;;){
        float oldVal = uintBitsToFloat(oldBits);
        uint newBits = floatBitsToUint(oldVal + operand);
        uint prev = atomicCompSwap(weightSum_u[index], oldBits, newBits);
        if(prev == oldBits) return oldVal;
        oldBits = prev;
    }
}
float atomicAddTempSumDiss(uint index, float operand){
    uint oldBits = tempSumDiss_u[index];
    for(;;){
        float oldVal = uintBitsToFloat(oldBits);
        uint newBits = floatBitsToUint(oldVal + operand);
        uint prev = atomicCompSwap(tempSumDiss_u[index], oldBits, newBits);
        if(prev == oldBits) return oldVal;
        oldBits = prev;
    }
}

void main(){
    uvec3 gid = gl_GlobalInvocationID;
    if(gid.x >= uint(pc.gridSize.x) || gid.y >= uint(pc.gridSize.y) || gid.z >= uint(pc.gridSize.z))
        return;
    uint idx = idx3D(gid.x, gid.y, gid.z);
    float temp = temperature[idx];
    float tempDiff = temp - c_ambientTemperature;
    float tempFactor = min(tempDiff / 50.0, 1.0);
    float baseDissipationRate = 0.02 + tempFactor * 0.08;
    float maxDissipation = 0.3 + tempFactor * 0.3;
    vec3 v = velocity[idx].xyz;
    float mag = length(v);
    speed[idx] = mag;
    float dissipationFactor = baseDissipationRate;
    if(mag < velocityThreshold){
        float stationaryFactor = 1.0 - (mag / velocityThreshold);
        dissipationFactor = baseDissipationRate + stationaryFactor * (maxDissipation - baseDissipationRate);
    }
    if(solidGrid[idx] != 0) dissipationFactor *= 0.5;
    dissipationFactor = min(dissipationFactor, 0.5);
    float keepFraction = 1.0 - dissipationFactor;
    float dissipationAmount = temp * dissipationFactor;
    float x0 = float(gid.x);
    float y0 = float(gid.y);
    float z0 = float(gid.z);
    float fx = x0 + v.x * pc.deltaTime / pc.cellSize.x;
    float fy = y0 + v.y * pc.deltaTime / pc.cellSize.y;
    float fz = z0 + v.z * pc.deltaTime / pc.cellSize.z;
    fx = clamp(fx, 0.0, float(pc.gridSize.x) - 1.0);
    fy = clamp(fy, 0.0, float(pc.gridSize.y) - 1.0);
    fz = clamp(fz, 0.0, float(pc.gridSize.z) - 1.0);
    int xi = int(floor(fx));
    int yi = int(floor(fy));
    int zi = int(floor(fz));
    xi = max(0, min(xi, int(pc.gridSize.x) - 2));
    yi = max(0, min(yi, int(pc.gridSize.y) - 2));
    zi = max(0, min(zi, int(pc.gridSize.z) - 2));
    float wx = fx - float(xi);
    float wy = fy - float(yi);
    float wz = fz - float(zi);
    wx = clamp(wx, 0.0, 1.0);
    wy = clamp(wy, 0.0, 1.0);
    wz = clamp(wz, 0.0, 1.0);
    float tempToAdvect = temp * keepFraction;
    float sumValidWeights = 0.0;
    for(int dx = 0; dx <= 1; dx++){
        for(int dy = 0; dy <= 1; dy++){
            for(int dz = 0; dz <= 1; dz++){
                int nx = xi + dx;
                int ny = yi + dy;
                int nz = zi + dz;
                if(nx < 0 || nx >= int(pc.gridSize.x) ||
                   ny < 0 || ny >= int(pc.gridSize.y) ||
                   nz < 0 || nz >= int(pc.gridSize.z)) continue;
                uint nidx = idx3D(uint(nx), uint(ny), uint(nz));
                float weight = (dx == 1 ? wx : (1.0 - wx)) *
                               (dy == 1 ? wy : (1.0 - wy)) *
                               (dz == 1 ? wz : (1.0 - wz));
                if(weight > 1e-6){
                    atomicAddTempSum(nidx, tempToAdvect * weight);
                    atomicAddWeightSum(nidx, weight);
                    sumValidWeights += weight;
                }
            }
        }
    }
    float lostWeight = 1.0 - sumValidWeights;
    if(lostWeight > 1e-6){
        for(int dx = -1; dx <= 1; dx++){
            for(int dy = -1; dy <= 1; dy++){
                for(int dz = -1; dz <= 1; dz++){
                    int nx = xi + dx;
                    int ny = yi + dy;
                    int nz = zi + dz;
                    if(nx < 0 || nx >= int(pc.gridSize.x) ||
                       ny < 0 || ny >= int(pc.gridSize.y) ||
                       nz < 0 || nz >= int(pc.gridSize.z)) continue;
                    uint nidx = idx3D(uint(nx), uint(ny), uint(nz));
                    atomicAddTempSum(nidx, tempToAdvect * lostWeight / 27.0);
                    atomicAddWeightSum(nidx, lostWeight / 27.0);
                }
            }
        }
    }
    if(dissipationAmount > 1e-6){
        int neighborCount = 0;
        const ivec3 neighbors[6] = {
            ivec3(-1, 0, 0), ivec3(1, 0, 0),
            ivec3(0, -1, 0), ivec3(0, 1, 0),
            ivec3(0, 0, -1), ivec3(0, 0, 1)
        };
        for(int n = 0; n < 6; n++){
            int ni = int(gid.x) + neighbors[n].x;
            int nj = int(gid.y) + neighbors[n].y;
            int nk = int(gid.z) + neighbors[n].z;
            if(ni >= 0 && ni < int(pc.gridSize.x) &&
               nj >= 0 && nj < int(pc.gridSize.y) &&
               nk >= 0 && nk < int(pc.gridSize.z))
                neighborCount++;
        }
        if(neighborCount > 0){
            float dissipationPerNeighbor = dissipationAmount / float(neighborCount);
            for(int n = 0; n < 6; n++){
                int ni = int(gid.x) + neighbors[n].x;
                int nj = int(gid.y) + neighbors[n].y;
                int nk = int(gid.z) + neighbors[n].z;
                if(ni >= 0 && ni < int(pc.gridSize.x) &&
                   nj >= 0 && nj < int(pc.gridSize.y) &&
                   nk >= 0 && nk < int(pc.gridSize.z)){
                    uint nidx = idx3D(uint(ni), uint(nj), uint(nk));
                    float absorptionFactor = solidGrid[nidx] == 0 ? 1.0 : 0.3;
                    float dissipatedToNeighbor = dissipationPerNeighbor * absorptionFactor;
                    atomicAddTempSumDiss(nidx, dissipatedToNeighbor);
                }
            }
        }

    }
}
