#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout(binding = 0, std430) restrict writeonly buffer DivergenceBuffer { float divergence[]; };
layout(binding = 5, std430) restrict readonly buffer VelocityBuffer { vec4 velocity[]; };
layout (binding = 14, std430) restrict readonly buffer SolidGridBuffer { uint solidGrid[]; };


layout(push_constant) uniform PushConstants {
    vec4 gridSize;
    vec4 worldMin;
    vec4 worldMax;
    vec4 cellSize;
    float deltaTime;
    uint numFans;
    int displayPressure;
    uint padding;
} pc;

uint idx3D(uint x, uint y, uint z){
    return uint(x + y * pc.gridSize.x + z * pc.gridSize.x * pc.gridSize.y);
}

bool isValidFluidCell(int x, int y, int z){
    if(x < 0 || x >= int(pc.gridSize.x) || 
       y < 0 || y >= int(pc.gridSize.y) || 
       z < 0 || z >= int(pc.gridSize.z)){
        return false;
    }
    uint idx = idx3D(uint(x), uint(y), uint(z));
    return solidGrid[idx] == 0;
}

void main(){
    uvec3 gid = gl_GlobalInvocationID;
    if(gid.x >= uint(pc.gridSize.x) || gid.y >= uint(pc.gridSize.y) || gid.z >= uint(pc.gridSize.z))
        return;
    uint idx = idx3D(gid.x, gid.y, gid.z);
    if(solidGrid[idx] != 0){
        divergence[idx] = 0.0;
        return;
    }
    
    float div = 0.0;
    if(gid.x > 0 && gid.x < uint(pc.gridSize.x) - 1){
        uint rightIdx = idx3D(gid.x + 1, gid.y, gid.z);
        uint leftIdx = idx3D(gid.x - 1, gid.y, gid.z);
        float uRight = isValidFluidCell(int(gid.x) + 1, int(gid.y), int(gid.z)) ? velocity[rightIdx].x : 0.0;
        float uLeft = isValidFluidCell(int(gid.x) - 1, int(gid.y), int(gid.z)) ? velocity[leftIdx].x : 0.0;
        div += (uRight - uLeft) / (2.0 * pc.cellSize.x);
    }
    if(gid.y > 0 && gid.y < uint(pc.gridSize.y) - 1){
        uint upIdx = idx3D(gid.x, gid.y + 1, gid.z);
        uint downIdx = idx3D(gid.x, gid.y - 1, gid.z);
        float vUp = isValidFluidCell(int(gid.x), int(gid.y) + 1, int(gid.z)) ? velocity[upIdx].y : 0.0;
        float vDown = isValidFluidCell(int(gid.x), int(gid.y) - 1, int(gid.z)) ? velocity[downIdx].y : 0.0;
        div += (vUp - vDown) / (2.0 * pc.cellSize.y);
    }
    if(gid.z > 0 && gid.z < uint(pc.gridSize.z) - 1){
        uint frontIdx = idx3D(gid.x, gid.y, gid.z + 1);
        uint backIdx = idx3D(gid.x, gid.y, gid.z - 1);
        float wFront = isValidFluidCell(int(gid.x), int(gid.y), int(gid.z) + 1) ? velocity[frontIdx].z : 0.0;
        float wBack = isValidFluidCell(int(gid.x), int(gid.y), int(gid.z) - 1) ? velocity[backIdx].z : 0.0;
        div += (wFront - wBack) / (2.0 * pc.cellSize.z);
    }
    divergence[idx] = div;
}