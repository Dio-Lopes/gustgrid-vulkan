#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout(binding = 0, std430) restrict writeonly buffer DivergenceBuffer { float divergence[]; };
layout(binding = 5, std430) restrict readonly buffer VelocityBuffer { vec4 velocity[]; };
layout (binding = 14, std430) restrict readonly buffer SolidGridBuffer { uint solidGrid[]; };


layout(push_constant) uniform PushConstants {
    vec3 gridSize;
    vec3 worldMin;
    vec3 worldMax;
    vec3 cellSize;
    float deltaTime;
    uint numFans;
    uint _pad[2];
    vec3 fanPositions[8];
    vec3 fanDirections[8];
    int displayPressure;
} pc;

uint idx3D(uint x, uint y, uint z){
    return uint(x + y * pc.gridSize.x + z * pc.gridSize.x * pc.gridSize.y);
}

bool isValidFluidCell(uint x, uint y, uint z){
    if(x < 0 || x >= pc.gridSize.x || 
       y < 0 || y >= pc.gridSize.y || 
       z < 0 || z >= pc.gridSize.z){
        return false;
    }
    uint idx = idx3D(x, y, z);
    return solidGrid[idx] == 0;
}

void main(){
    uvec3 gid = gl_GlobalInvocationID;
    if(gid.x >= uint(pc.gridSize.x) || gid.y >= uint(pc.gridSize.y) || gid.z >= uint(pc.gridSize.z))
        return;
    uint idx = idx3D(gid.x, gid.y, gid.z);
    if(solidGrid[idx] != 0){
        divergence[idx] = 0.0;
        return;
    }
    float div = 0.0;
    if(gid.x < uint(pc.gridSize.x) - 1 && gid.x > 0){
        float uRight = isValidFluidCell(gid.x + 1, gid.y, gid.z) ? velocity[idx3D(gid.x + 1, gid.y, gid.z)].x : 0.0;
        float uLeft = isValidFluidCell(gid.x - 1, gid.y, gid.z) ? velocity[idx3D(gid.x - 1, gid.y, gid.z)].x : 0.0;
        div += (uRight - uLeft) * (1.0 / (2.0 * pc.cellSize.x));
    }
    if(gid.y < uint(pc.gridSize.y) - 1 && gid.y > 0){
        float vUp = isValidFluidCell(gid.x, gid.y + 1, gid.z) ? velocity[idx3D(gid.x, gid.y + 1, gid.z)].y : 0.0;
        float vDown = isValidFluidCell(gid.x, gid.y - 1, gid.z) ? velocity[idx3D(gid.x, gid.y - 1, gid.z)].y : 0.0;
        div += (vUp - vDown) * (1.0 / (2.0 * pc.cellSize.y));
    }
    if(gid.z < uint(pc.gridSize.z) - 1 && gid.z > 0){
        float wFront = isValidFluidCell(gid.x, gid.y, gid.z + 1) ? velocity[idx3D(gid.x, gid.y, gid.z + 1)].z : 0.0;
        float wBack = isValidFluidCell(gid.x, gid.y, gid.z - 1) ? velocity[idx3D(gid.x, gid.y, gid.z - 1)].z : 0.0;
        div += (wFront - wBack) * (1.0 / (2.0 * pc.cellSize.z));
    }
    divergence[idx] = div;
}