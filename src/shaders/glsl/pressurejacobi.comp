#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout(binding = 0, std430) restrict readonly buffer DivergenceBuffer { float divergence[]; };
layout(binding = 8, std430) restrict readonly buffer PressureTempBuffer { float pressureTemp[]; };
layout(binding = 2, std430) restrict writeonly buffer PressureOutBuffer { float pressureOut[]; };
layout(binding = 14, std430) restrict readonly buffer SolidGridBuffer { uint solidGrid[]; };

layout(push_constant) uniform PushConstants {
    vec4 gridSize;
    vec4 worldMin;
    vec4 worldMax;
    vec4 cellSize;
    float deltaTime;
    uint numFans;
    int displayPressure;
    uint padding;
    vec4 fanPositions[8];
    vec4 fanDirections[8];
} pc;

uint idx3D(uint x, uint y, uint z){
    return uint(x + y * pc.gridSize.x + z * pc.gridSize.x * pc.gridSize.y);
}

shared float s_pressure[10][10][10];
shared uint s_solid[10][10][10];

void main(){
    uvec3 gid = gl_GlobalInvocationID;
    int tx = int(gl_LocalInvocationID.x) + 1;
    int ty = int(gl_LocalInvocationID.y) + 1;
    int tz = int(gl_LocalInvocationID.z) + 1;
    s_pressure[tx][ty][tz] = 0.0;
    s_solid[tx][ty][tz] = 1;
    if(gid.x < uint(pc.gridSize.x) && gid.y < uint(pc.gridSize.y) && gid.z < uint(pc.gridSize.z)){
        uint idx = idx3D(gid.x, gid.y, gid.z);
        s_pressure[tx][ty][tz] = pressureTemp[idx];
        s_solid[tx][ty][tz] = solidGrid[idx];
        if(gl_LocalInvocationID.x == 0 && gid.x > 0){
            uint leftIdx = idx3D(gid.x-1, gid.y, gid.z);
            s_pressure[0][ty][tz] = pressureTemp[leftIdx];
            s_solid[0][ty][tz] = solidGrid[leftIdx];
        }
        if(gl_LocalInvocationID.x == gl_WorkGroupSize.x-1 && gid.x < uint(pc.gridSize.x)-1){
            uint rightIdx = idx3D(gid.x+1, gid.y, gid.z);
            s_pressure[tx+1][ty][tz] = pressureTemp[rightIdx];
            s_solid[tx+1][ty][tz] = solidGrid[rightIdx];
        }
        if(gl_LocalInvocationID.y == 0 && gid.y > 0){
            uint downIdx = idx3D(gid.x, gid.y-1, gid.z);
            s_pressure[tx][0][tz] = pressureTemp[downIdx];
            s_solid[tx][0][tz] = solidGrid[downIdx];
        }
        if(gl_LocalInvocationID.y == gl_WorkGroupSize.y-1 && gid.y < uint(pc.gridSize.y)-1){
            uint upIdx = idx3D(gid.x, gid.y+1, gid.z);
            s_pressure[tx][ty+1][tz] = pressureTemp[upIdx];
            s_solid[tx][ty+1][tz] = solidGrid[upIdx];
        }
        if(gl_LocalInvocationID.z == 0 && gid.z > 0){
            uint backIdx = idx3D(gid.x, gid.y, gid.z-1);
            s_pressure[tx][ty][0] = pressureTemp[backIdx];
            s_solid[tx][ty][0] = solidGrid[backIdx];
        }
        if(gl_LocalInvocationID.z == gl_WorkGroupSize.z-1 && gid.z < uint(pc.gridSize.z)-1){
            uint frontIdx = idx3D(gid.x, gid.y, gid.z+1);
            s_pressure[tx][ty][tz+1] = pressureTemp[frontIdx];
            s_solid[tx][ty][tz+1] = solidGrid[frontIdx];
        }
    }
    barrier();
    if(gid.x >= uint(pc.gridSize.x) || gid.y >= uint(pc.gridSize.y) || gid.z >= uint(pc.gridSize.z)) return;
    uint idx = idx3D(gid.x, gid.y, gid.z);
    if(solidGrid[idx] != 0){
        pressureOut[idx] = 0.0;
        return;
    }
    float neighborPressureSum = 0.0;
    int neighborCount = 0;
    if(gid.x > 0 && s_solid[tx-1][ty][tz] == 0){
        neighborPressureSum += s_solid[tx-1][ty][tz] == 0 ? s_pressure[tx-1][ty][tz] : s_pressure[tx][ty][tz];
        neighborCount++;
    }
    if(gid.x < uint(pc.gridSize.x)-1 && s_solid[tx+1][ty][tz] == 0){
        neighborPressureSum += s_solid[tx+1][ty][tz] == 0 ? s_pressure[tx+1][ty][tz] : s_pressure[tx][ty][tz];
        neighborCount++;
    }
    if(gid.y > 0 && s_solid[tx][ty-1][tz] == 0){
        neighborPressureSum += s_solid[tx][ty-1][tz] == 0 ? s_pressure[tx][ty-1][tz] : s_pressure[tx][ty][tz];
        neighborCount++;
    }
    if(gid.y < uint(pc.gridSize.y)-1 && s_solid[tx][ty+1][tz] == 0){
        neighborPressureSum += s_solid[tx][ty+1][tz] == 0 ? s_pressure[tx][ty+1][tz] : s_pressure[tx][ty][tz];
        neighborCount++; 
    }
    if(gid.z > 0 && s_solid[tx][ty][tz-1] == 0){
        neighborPressureSum += s_solid[tx][ty][tz-1] == 0 ? s_pressure[tx][ty][tz-1] : s_pressure[tx][ty][tz];
        neighborCount++;
    }
    if(gid.z < uint(pc.gridSize.z)-1 && s_solid[tx][ty][tz+1] == 0){
        neighborPressureSum += s_solid[tx][ty][tz+1] == 0 ? s_pressure[tx][ty][tz+1] : s_pressure[tx][ty][tz];
        neighborCount++;
    }
    if(neighborCount == 0){
        pressureOut[idx] = 0.0;
        return;
    }
    float beta = 0.6;
    float avgCellSize = (pc.cellSize.x + pc.cellSize.y + pc.cellSize.z) / 3.0;
    float scale = avgCellSize * avgCellSize / pc.deltaTime;
    float newPressure = (neighborPressureSum - divergence[idx] * scale) / float(neighborCount);
    pressureOut[idx] = (1.0f - beta) * pressureTemp[idx] + beta * newPressure;
}