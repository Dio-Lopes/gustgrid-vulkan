#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout(binding = 4, std430) restrict writeonly buffer TempVelocityBuffer { vec4 tempVelocity[]; };
layout(binding = 5, std430) restrict readonly buffer VelocityBuffer { vec4 velocity[]; };
layout(binding = 7, std430) restrict readonly buffer TemperatureBuffer { float temperature[]; };
layout(binding = 13, std430) restrict readonly buffer FanAccessBuffer { uint fanAccess[]; };
layout (binding = 14, std430) restrict readonly buffer SolidGridBuffer { uint solidGrid[]; };

layout(push_constant) uniform PushConstants {
    vec4 gridSize;
    vec4 worldMin;
    vec4 worldMax;
    vec4 cellSize;
    float deltaTime;
    uint numFans;
    int displayPressure;
    uint padding;
    vec4 fanPositions[8];
    vec4 fanDirections[8];
} pc;

const float c_referenceDensity = 1.225;
const float c_thermalExpansionCoefficient = 0.00343;
const float c_ambientTemperature = 22.0;
const float c_buoyancyFactor = 0.5;
const float c_gravity = 9.81;

uint idx3D(uint x, uint y, uint z){
    return uint(x + y * pc.gridSize.x + z * pc.gridSize.x * pc.gridSize.y);
}

void main(){
    uvec3 gid = gl_GlobalInvocationID;
    if(gid.x >= uint(pc.gridSize.x) || gid.y >= uint(pc.gridSize.y) || gid.z >= uint(pc.gridSize.z))
        return;
    uint idx = idx3D(gid.x, gid.y, gid.z);
    if(solidGrid[idx] != 0){
        tempVelocity[idx] = vec4(0.0);
        return;
    }
    vec3 v = velocity[idx].xyz;
    float solidProximity = 0.0;
    int solidCount = 0;
    for(int dx=-1; dx<=1; dx++){
        for(int dy=-1; dy<=1; dy++){
            for(int dz=-1; dz<=1; dz++){
                int ni = int(gid.x + dx);
                int nj = int(gid.y + dy);
                int nk = int(gid.z + dz);
                if(ni >= 0 && ni < int(pc.gridSize.x) &&
                   nj >= 0 && nj < int(pc.gridSize.y) &&
                   nk >= 0 && nk < int(pc.gridSize.z)){
                    uint nidx = idx3D(uint(ni), uint(nj), uint(nk));
                    if(solidGrid[nidx] != 0){
                        float dist = length(vec3(dx, dy, dz));
                        solidProximity += 1.0 / (dist + 0.1);
                        solidCount++;
                    }
                }
            }
        }
    }
    float advectionStrength = 0.8 / (1.0 + solidProximity * 0.3);
    float x0 = float(gid.x) - v.x * pc.deltaTime * advectionStrength / pc.cellSize.x;
    float y0 = float(gid.y) - v.y * pc.deltaTime * advectionStrength / pc.cellSize.y;
    float z0 = float(gid.z) - v.z * pc.deltaTime * advectionStrength / pc.cellSize.z;
    x0 = min(max(x0, 0.5), pc.gridSize.x - 1.5);
    y0 = min(max(y0, 0.5), pc.gridSize.y - 1.5);
    z0 = min(max(z0, 0.5), pc.gridSize.z - 1.5);
    int xi = int(x0);
    int yi = int(y0);
    int zi = int(z0);
    float fx = x0 - float(xi);
    float fy = y0 - float(yi);
    float fz = z0 - float(zi);
    xi = clamp(xi, 0, int(pc.gridSize.x) - 2);
    yi = clamp(yi, 0, int(pc.gridSize.y) - 2);
    zi = clamp(zi, 0, int(pc.gridSize.z) - 2);
    vec3 newVel = v;
    float sumW = 0.0;
    vec3 acc = vec3(0.0);
    for(int dx=0; dx<=1; dx++){
        for(int dy=0; dy<=1; dy++){
            for(int dz=0; dz<=1; dz++){
                int nx = xi + dx;
                int ny = yi + dy;
                int nz = zi + dz;
                if(nx >= 0 && nx < int(pc.gridSize.x) &&
                    ny >= 0 && ny < int(pc.gridSize.y) &&
                    nz >= 0 && nz < int(pc.gridSize.z)){
                    uint nidx = idx3D(uint(nx), uint(ny), uint(nz));
                    float w = (dx != 0 ? fx : (1.0 - fx)) *
                                (dy != 0 ? fy : (1.0 - fy)) *
                                (dz != 0 ? fz : (1.0 - fz));
                    if(solidGrid[nidx] == 0){
                        vec3 val = velocity[nidx].xyz;
                        acc += w * val;
                        sumW += w;
                    }
                }
            }
        }
    }
    newVel = sumW > 1e-6 ? acc / sumW : newVel;
    float worldX = (float(gid.x) + 0.5) * pc.cellSize.x + pc.worldMin.x;
    float worldY = (float(gid.y) + 0.5) * pc.cellSize.y + pc.worldMin.y;
    float worldZ = (float(gid.z) + 0.5) * pc.cellSize.z + pc.worldMin.z;
    vec3 fanAccum = vec3(0.0);
    uint numCells = uint(pc.gridSize.x * pc.gridSize.y * pc.gridSize.z);
    for(uint f=0; f<pc.numFans; f++){
        uint fanIdx = f * numCells + idx;
        if(fanAccess[fanIdx] == 0) continue;
        vec3 fanPos = pc.fanPositions[f].xyz;
        vec3 fanDir = pc.fanDirections[f].xyz;
        vec3 toCell = vec3(worldX, worldY, worldZ) - fanPos;
        float distSq = dot(toCell, toCell);
        if(distSq < 1e-6) continue;
        float invDist = inversesqrt(distSq);
        float dist = sqrt(distSq);
        vec3 toCellNorm = toCell * invDist;
        float alignment = dot(fanDir, toCellNorm);
        float fanRadiusSq = 0.4;
        float forceMagnitude = 5.0 * alignment / (1.0 + distSq / fanRadiusSq);
        if(alignment > 0.1) fanAccum += forceMagnitude * fanDir;
        else if(alignment < 0.1) fanAccum -= forceMagnitude * fanDir;
        if(abs(alignment) > 0.1 && dist > 0.2){
            float axialDistance = alignment * dist;
            vec3 axialPoint = fanPos + axialDistance * fanDir;
            vec3 radialVec = vec3(worldX, worldY, worldZ) - axialPoint;
            float radialDistSq = dot(radialVec, radialVec);
            if(radialDistSq > 1e-6){
                float invRadialDist = inversesqrt(radialDistSq);
                float radialStrength = 0.5 / (distSq + 0.5);
                if(alignment > 0.0) fanAccum += radialStrength * invRadialDist * radialVec;
                else fanAccum -= radialStrength * invRadialDist * radialVec;
            }
        }
    }
    newVel += fanAccum;
    float tempDiff = temperature[idx] - c_ambientTemperature;
    if(tempDiff > 2.0){
        float densityChange = -c_referenceDensity * c_thermalExpansionCoefficient * tempDiff;
        float buoyancyForce = densityChange * c_gravity * c_buoyancyFactor / c_referenceDensity;
        float maxBuoyancyAccel = 20.0;
        buoyancyForce = clamp(buoyancyForce, -maxBuoyancyAccel, maxBuoyancyAccel);
        buoyancyForce *= (1.0 - solidProximity * 0.2);
        newVel.y += buoyancyForce * pc.deltaTime;
    }
    if(solidCount > 0 && tempDiff > 10.0){
        float backPressure = solidProximity * tempDiff * 0.001;
        vec3 awayFromSolid = vec3(0.0);
        for(int dx=-1; dx<=1; dx++){
            for(int dy=-1; dy<=1; dy++){
                for(int dz=-1; dz<=1; dz++){
                    int ni = int(gid.x) + dx;
                    int nj = int(gid.y) + dy;
                    int nk = int(gid.z) + dz;
                    if(ni >= 0 && ni < int(pc.gridSize.x) && nj >= 0 && nj < int(pc.gridSize.y) && nk >= 0 && nk < int(pc.gridSize.z)){
                        uint nidx = idx3D(uint(ni), uint(nj), uint(nk));
                        if(solidGrid[nidx] != 0){
                            awayFromSolid -= vec3(dx, dy, dz) * backPressure;
                        }
                    }
                }
            }
        }
        newVel += awayFromSolid * pc.deltaTime;
    }
    if(tempDiff > 5.0){
        vec3 gradient = vec3(0.0);
        if(gid.x > 0 && gid.x < uint(pc.gridSize.x) - 1){
            uint leftIdx = idx3D(gid.x - 1, gid.y, gid.z);
            uint rightIdx = idx3D(gid.x + 1, gid.y, gid.z);
            if(solidGrid[leftIdx] == 0 && solidGrid[rightIdx] == 0)
                gradient.x = (temperature[rightIdx] - temperature[leftIdx]) / (2.0 * pc.cellSize.x);
        } if(gid.y > 0 && gid.y < uint(pc.gridSize.y) - 1){
            uint downIdx = idx3D(gid.x, gid.y - 1, gid.z);
            uint upIdx = idx3D(gid.x, gid.y + 1, gid.z);
            if(solidGrid[downIdx] == 0 && solidGrid[upIdx] == 0)
                gradient.y = (temperature[upIdx] - temperature[downIdx]) / (2.0 * pc.cellSize.y);
        } if(gid.z > 0 && gid.z < uint(pc.gridSize.z) - 1){
            uint backIdx = idx3D(gid.x, gid.y, gid.z - 1);
            uint frontIdx = idx3D(gid.x, gid.y, gid.z + 1);
            if(solidGrid[backIdx] == 0 && solidGrid[frontIdx] == 0)
                gradient.z = (temperature[frontIdx] - temperature[backIdx]) / (2.0 * pc.cellSize.z);
        }
        float convectionStrength = min(tempDiff * tempDiff * 0.001, 0.5);
        vec3 convection = -convectionStrength * gradient;
        if(tempDiff > 20.0){
            float thermalSpreadForce = min(tempDiff * 0.0002, 0.01);
            float circX = (worldZ - pc.worldMin.z - (pc.worldMax.z - pc.worldMin.z) * 0.5) * 0.02;
            float circZ = -(worldX - pc.worldMin.x - (pc.worldMax.x - pc.worldMin.x) * 0.5) * 0.02;
            convection.x += thermalSpreadForce * circX;
            convection.z += thermalSpreadForce * circZ;
        }
        newVel += convection * pc.deltaTime;
    }
    const float maxVel = 20.0;
    float damping = 0.98 - min(tempDiff * 0.001, 0.05);
    damping -= solidProximity * 0.02;
    damping = max(damping, 0.85);
    vec3 clampedVel = clamp(newVel, -maxVel, maxVel) * damping;
    tempVelocity[idx] = vec4(clampedVel, 0.0);
}